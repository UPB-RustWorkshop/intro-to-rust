<!DOCTYPE html>
<html>
  <head>
    <title>Rust, a modern alternative to C and C++</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style/style.css"></link>
    <style>
      
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Rust, a modern alternative to C and C++

.small[.center[![IoT Services and Architectures](images/rust_logo.png)]]

.left[
Based on: [Rust ISP 2019](https://github.com/newpavlov/rust-isp-2019) slides  
Alexandru Radovici, illustrations by [Mieuneli](http://miau.laura.ro)
]

---

class: split-70
# The C language

.column[
- Invented in 1972
- Purpose: writing UNIX
- Standard: ANSI C
- Issues
  - No library
  - No strings, just arrays of `char`
  - No data collections library 
  - ASCII characters
  - No bounds verification
  - Pointer arithmetic
  - No memory management
- Pros
  - Fast
  - The only language (except `C++` and `Pascal`) usable for writing an OS
  - Works on small embedded devices
]

.column[
.small[.center[![Denis Ritchie](images/Dennis_Ritchie_2011.jpg)]]
]

---

class: split-70
# The C++ language

.column[
- Invented in 1985
- Purpose: improvement to C
- Standard: ISO/IEC 14882
- Issues
  - ASCII characters
  - No bounds verification
  - Pointer arithmetic
  - No memory management
  - Diamond Problem (multiple inheritance)
  - Too many compiler flavours
  - Too many standard versions
  - No template verification
- Pros
  - Fast
  - Allows the writing of an OS (Linux did not accept it in the kernel)
  - Works on small embedded devices
]

.column[
.small[.center[![Bjarne Stroustrup](images/Bjarne-Stroustrup.jpg)]]
]

---

class: split-70
# The Rust language

.column[
- Invented in 2015
- Purpose: safe systems language
  - replacement for C and C++
- Standard: The Rust Language
- Pros
  - No dangling pointers
  - Memory management
  - Data collections library
  - Works on small embedded devices
  - No implicit typecast
  - Bounds verification
  - Fast
  - Allows the writing of an OS (Linux did accept it in the kernel)
- Issues
  - Panics
  - Macros
]

.column[
.small[.center[![Graydon Hoare](images/Graydon-Hoare.jpeg)]]
.small[.center[![Rust Logo](images/rust_logo.png)]]
]

---

# Items to talk

An introduction to [Rust](https://www.rust-lang.org/).

- Quick overview
- Ownership and Borrows
- Enums with payload
- No NULL references
- Lifetime annotations

---

# Simple Rust 

```rust
fn main() {
    println!("Hello, world!");
}
```

- `println!` is a macro, not a function, it replaces code
- function `main` does not return a value (almost true)

.card[.large[.center[![Hello Rust](images/sep_hello.png)]]]

---
## `print!` & `println!`
- Print stuff out. Yay.
- Use `{}` for general string interpolation, and `{:?}` for debug printing.
    - Some types can only be printed with `{:?}`, like arrays and `Vec`s.

```rust
print!("{}, {}, {}", "foo", 3, true);
// => foo, 3, true
println!("{:?}, {:?}", "foo", [1, 2, 3]);
// => "foo", [1, 2, 3]
```


## `format!` 
- Uses `println!`-style string interpolation to create formatted `String`s.

```rust
let fmted = format!("{}, {:x}, {:?}", 12, 155, [1,2,3]);
// fmted == "12, 9b, [1,2,3]"
```

---

## Variable Bindings ###
- Variables are bound with `let`:
```rust
let x = 17;
```

- Bindings are implicitly-typed: the compiler infers based on context.
- The compiler can't always determine the type of a variable, so sometimes you
  have to add type annotations.
```rust
let x: i16 = 17;
```

- Variables are inherently immutable:
```rust
let x = 5;
x += 1; // error: re-assignment of immutable variable x
let mut y = 5;
y += 1; // OK!
```

---
## Variable Bindings ###
- Bindings may be shadowed:
```rust
let x = 17;
let y = 53;
let x = "Shadowed!";
// x is not mutable, but we're able to re-bind it
```

- The shadowed binding for `x` above lasts until it goes out of scope.
- Above, we've effectively lost the first binding, since both `x`s are in the same scope.

- Patterns may also be used to declare variables:
```rust
let (a, b) = ("foo", 12);
let [c, d] = [1, 2];
```

---
## Primitive Types 

- `unit`: () (similar with `void` from C)
- `bool`: `true` and `false`
- `char`: `'c'` or `'ðŸ˜º'` (`char`s are Unicode code-points, i.e. 4 bytes long!)

- Numerics: specify the signedness and size.
    - `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
    - `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
    - `f32`, `f64`, `f128`
    - `isize` & `usize` are the size of pointers (and therefore have
        machine-dependent size)
    - Literals are spelled like `10i8`, `10u16`, `10.0f32`, `10usize`.
    - Type inference for non-specific literals default to `i32` or `f64`:
      - e.g. `10` defaults to `i32`, `10.0` defaults to `f64`.

---

## Arrays
- Arrays are generically of type `[T; N]`.
    - N is a compile-time _constant_. Arrays cannot be resized.
    - Array access is bounds-checked at runtime.
- Arrays are indexed with `[]` like most other languages:
    - `arr[3]` gives you the 4th element of `arr`

```rust
let arr1 = [1, 2, 3]; // (array of 3 elements)
let arr2 = [2; 32];   // (array of 32 `2`s)
```

---
## Slices
- Generically of type `&[T]`
- A "view" into an array (or heap allocated data) by reference
- Not created directly, but are borrowed from other variables
- Mutable `&mut [T]` or immutable `&[T]`

```rust
let arr = [0, 1, 2, 3, 4, 5];
let val = arr[0];               // val = 0
let total_slice = &arr;         // Slice all of `arr`
let total_slice = &arr[..];     // Same, but more explicit
let partial_slice = &arr[2..5]; // [2, 3, 4]
```

---
## Strings
- Two types of Rust strings: `String` and `&str`.
- `String` is a heap-allocated, growable vector of characters.
- `&str` is a type&sup1; that's used to slice into `String`s.
- String literals like `"foo"` are of type `&str`.
- Strings are guaranteed to be encoded using UTF-8

```rust
let s: &str = "galaxy";
let s2: String = "Ð³Ð°Ð»Ð°ÐºÑ‚Ð¸ÐºÐ°".to_string();
let s3: String = String::from("éŠ€æ¼¢");
let s4: &str = &s3;
```

```rust
let s1 = "foobar";
// You can slice strings:
let s2 = &s1[1..3];
// But you can't index with []
// you can use `s1.chars().nth(1).unwrap()` instead
let s3 = s1[1] // does not work!
```

&sup1;`str` is an unsized type, which doesn't have a compile-time known size,
and therefore cannot exist by itself.

---
## Casting 

- Cast between types with `as`:

```rust
let x: i32 = 100;
let y: u32 = x as u32;
```

- Naturally, you can only cast between types that are safe to cast between.
    - No casting `[i16; 4]` to `char`! (This is called a "non-scalar" cast)
    - There are unsafe mechanisms to overcome this, if you know what you're doing.


---
## If Statements

```rust
let x = 10;

if x > 0 {
    println! ("positive");
} else if x == 0 {
    println! ("zero");
} else {
    println! ("negative");
}
```

- No parentheses necessary.
- Entire if statement evaluates to one expression, so every arm must end with
  an expression of the same type.
    - In this example is it unit `()`:

---
### Workpoint .top_image[![Work In Progress](images/work_in_progress.png)]

Assign to `max` the value of the maximum between a and b  without changing its mutability.

```rust
let a = 10;
let b = 100;
let max = ...

println! ("The maximum {}", max);
```

Remember, **almost everything is an expression** that returns a value.

---

## `match` 
- `switch` on steroids.

```rust
let x = 3;

match x {
    1 => println!("one fish"),  // <- comma required
    2 => {
        println!("two fish");
        println!("two fish");
    },  // <- comma optional when using braces
    // we can match several patterns in one arm
    3 | 4 => println!("three or four, dunno"),
    _ => println!("no fish for you"), // "otherwise" case
}
```

- `match` takes an expression (`x`) and branches on a list of `value => expression` statements.
- The entire match evaluates to one expression.
    - Like `if`, all arms must evaluate to the same type.
- `_` is commonly used as a catch-all (cf. Haskell, OCaml)

---

## `match` pattern
```rust
let x = 3;
let y = -3;
let q = 10;

let s = match (x, y) {
    (1, 1) => "one".to_string(),
    (2, j) => format!("two, {}", j),
    (_, 3) => "three".to_string(),
    (i, j) if i > 5 && j < 0 => "On guard!".to_string(),
    // NB: note that we do not test x == 10 here!
    (q, k) => format!("???: {} {}", q, k),
};
println!("{}", s);
```

- The matched expression can be any expression (l-value), including tuples and function calls.
    - Matches can bind variables. `_` is a throw-away variable name.
- You _must_ write an exhaustive match in order to compile.
- Use `if`-guards to constrain a match to certain conditions.
- Patterns can get very complex.
---

## `while` 
- Loops come in three flavors: `while`, `loop`, and `for`.
    - `break` and `continue` exist just like in most languages

- `while` works just like you'd expect:

```rust
let mut x = 0;
while x < 100 {
    x += 1;
    println!("x: {}", x);
}
```

While loops are not expressions.

---

### Workpoint .top_image[![Work In Progress](images/work_in_progress.png)]

Make a `while` behave like a `do while`.

```rust
let mut x = 0;
while x < 100 {
    x += 1;
    println!("x: {}", x);
}
```

Remember, **almost everything is an expression** that returns a value and a block { } is evaluated to the value of its last expression.

---
## `loop` 
- `loop` is equivalent to `while true`, a common pattern.
    - Plus, the compiler can make optimizations knowing that it's infinite.

```rust
let mut x = 0;
loop {
    x += 1;
    println!("x: {}", x);
}
```

Loops are expressions, they *return* using `break`.

---
## `for` iteration
- `for` is the most different from most C-like languages
     - `for` loops use an _iterator expression_:
     - `n..m` creates an iterator from n to m (exclusive).
     - Some data structures can be used as iterators, like arrays and `Vec`s.

```rust
// Loops from 0 to 9.
for x in 0..10 {
    println!("{}", x);
}

let xs = [0, 1, 2, 3, 4];
// Loop through elements in a slice of `xs`.
for x in &xs {
    println!("{}", x);
}
```

For loops are not expressions.

---
### Workpoint .top_image[![Work In Progress](images/work_in_progress.png)]

Assign to `max` the value of the maximum number in the array. Do not use any function.

```rust
let v = [1,2,4,5,23,54,6,7,34,6,6,3];
let max = v[0];
// ...

println! ("The maximum {}", max);
```

Remember array slices are iterators that return references to array elements.

---
class: split-50
## Functions 

```rust
fn foo(x: T, y: U, z: V) -> T {
    // ...
}
```
.column[
- `foo` is a function that takes three parameters:
    - `x` of type `T`
    - `y` of type `U`
    - `z` of type `V`
- `foo` returns a `T`.
]

.column[
.card[.small[.center[![Function](images/sep_function.png)]]]
]

<br>

- Must explicitly define argument and return types.
    - The compiler is actually smart enough to figure this out for you, but
      Rust's designers decided it was better practice to force explicit function
      typing.

---
## Functions Return

- The final expression in a function is its return value.
    - Use `return` for _early_ returns from a function.

```rust
fn square(n: i32) -> i32 {
    n * n
}

fn squareish(n: i32) -> i32 {
    if n < 5 { return n; }
    n * n
}

fn square_bad(n: i32) -> i32 {
    n * n;
}
```

- The last one won't even compile!
  - Why? 

---

### Workpoint .top_image[![Work In Progress](images/work_in_progress.png)]

1. Write the `maximum` function that returns the maximum of a and b

  ```rust
  let a = 10;
  let b = 100;
  let max = maximum (a, b);
  
  println! ("The maximum {}", max);
  ```

2.  Write the `maximum` function that returns the maximum element of `v`.

  ```rust
  let v = [1,2,4,5,23,54,6,7,34,6,6,3];
  let max = maximum (&v);
  
  println! ("The maximum {}", max);
  ```

  Hint: You have to send a refernce of `v` to the function.

---

# Ownership

- A variable binding _takes ownership_ of its data.
    - A piece of data can only have one owner at a time.
- When a binding goes out of scope, the bound data is released automatically. (`Drop` trait)
    - For heap-allocated data, this means de-allocation.
- Data _must be guaranteed_ to outlive its references.

```rust
fn foo() {
    // Creates a String
    // Gives ownership of the String object to s
    let s = String::from ("This text is owned by s");

    // At the end of the scope, s goes out of scope.
    // s still owns the String object, so it can be cleaned up.
}
```

---
## Ownership

So here are the basics.
- When you introduce a variable binding, it takes ownership of its data. And a
  piece of data can only have one owner at a time.
- When a variable binding goes out of scope, nothing has access to the data
  anymore, so it can be released. Which means, if it's on the heap, it can be
  de-allocated.
- And data must be guaranteed to outlive its references. Or, all references are
  guaranteed to be valid.

---
## Move Semantics

```rust
let s1 = String::from ("A string");

// Ownership of the String object moves to s2.
let s2 = s1;

println!("{}", s1); // error: use of moved value `s1`
```

- `let s2 = s1;`
    - We don't want to copy the data, since that's expensive.
    - The data cannot have multiple owners.
    - Solution: move the String's ownership into `s2`, and declare `s1` invalid.
- `println!("{}", s1);`
    - We know that `s1` is no longer a valid variable binding, so this is an error.
- Rust can reason about this at compile time, so it throws a compiler error.

---
## Move Semantics

- Moving ownership copies data. BUT:
    - Often moves are optimized out by compiler.
    - When we move ownership of a heap allocated data (e.g. `String`), we do
        not touch data on heap, just few bytes allocated on stack are copied
        (pointer to heap, length and capacity; 24 bytes on 64-bit machine)
- Moves are automatic (via assignments); no need to use something like C++'s
  `std::move`.
    - However, there are functions like `std::mem::replace` in Rust to provide
      advanced ownership management.
- For more finer-grained control see standrard library functions:
`std::mem::replace`, `std::mem::swap` and others.

---
## Ownership

- Ownership does not always have to be moved.
- What would happen if it did? Rust would get very tedious to write:

```rust
fn string_length(s: String) -> String {
    // Do whatever here,
    // then return ownership of `s` back to the caller
}
```
- You could imagine that this does not scale well either.
    - The more variables you had to hand back, the longer your return type would be!
    - Imagine having to pass ownership around for 5+ variables at a time :(

```rust
fn string_length(s1: String, s2: String, ...) -> (String, String, ...) {
    // Do whatever here,
    // then return ownership of `s1`, `s2`, ... back to the caller
}
```
---
## Borrowing

- Instead of transferring ownership, we can _borrow_ data.
- A variable's data can be borrowed by taking a reference to the variable;
  ownership doesn't change.
    - When a reference goes out of scope, the borrow is over.
    - The original variable retains ownership throughout.

```rust
let s = String::from ("string");

// s_ref is a reference to s.
let s_ref = &s;

// use s_ref to access the data in the String s.
assert_eq!(s.chars().nth(1), s_ref.chars().nth(1));
```

Rust does automatic dereferencing.

---
## Borrowing

- Caveat: this adds restrictions to the original variable.
- Ownership cannot be transferred from a variable while references to it exist.
    - That would invalidate the reference.

```rust
let s = String::from("for borrow");

// s_ref is a reference to s.
let s_ref = &s;

// Moving ownership to s_new would invalidate s_ref.
// error: cannot move out of `s` because it is borrowed
let s_new = s;

println! ("{}", s_ref);
```

Try it without the `println!`

---
## Borrowing

```rust
/// `length` only needs `String` temporarily, so it is borrowed.
fn length(str_ref: &String) -> usize {
    // vec_ref is auto-dereferenced when you call methods on it.
    str_ref.len()
    // you can also explicitly dereference.
    // (*str_ref).len()
}

fn main() {
    let s = String::new ();
    length(&s);
    println!("{:?}", s); // this is fine
}
```
- Note the type of `length`: `str_ref` is passed by reference, so it's now an `&String`.
- References, like bindings, are *immutable* by default.
- The borrow is over after the reference goes out of scope (at the end of `length`).

---
## Borrowing

```rust
/// `push` needs to modify `string` so it is borrowed mutably.
fn push(str_ref: &mut String, x: &str) {
    str_ref.push_str (x);
}

fn main() {
    let mut s: String = String::from ("");
    let string_ref: &mut String = &mut s;
    push(string_ref, "str");
    assert_eq!(string_ref, "str");
}
```
- Variables can be borrowed by _mutable_ reference: `&mut string_ref`.
    - `string_ref` is a reference to a mutable `String`.
    - The type is `&mut String`, not `&String`.
- Different from a reference which is variable.

---
## Borrowing

```rust
/// `push` needs to modify `string` so it is borrowed mutably.
fn push2(str_ref: &mut String, x: &str) {
    // error: cannot move out of borrowed content.
    let string = *str_ref;
    string.push_str(x);
}

fn main() {
    let mut vector = String::from ("");
    push2(&mut string, "a new str");
}
```
- Error! You can't dereference `string_ref` into a variable binding because that
  would change the ownership of the data.

---
## Borrowing

- Rust will auto-dereference variables...
    - When making method calls on a reference.
    - When passing a reference as a function argument.

```rust
/// `length` only needs `s` temporarily, so it is borrowed.
fn length(s_ref: &&String) -> usize {
    // s_ref is auto-dereferenced when you call methods on it.
    s_ref.len()
}

fn main() {
    let s = String::from("");
    length(&&&&&&&&&&&&s);
}
```

---
## Borrowing

- You will have to dereference variables...
    - When writing into them.
    - And other times that usage may be ambiguous.

```rust
let mut a = 5;
let ref_a = &mut a;
*ref_a = 4;
println!("{}", *ref_a + 4);
// ==> 8
```

---
## `Copy` Types

- Rust defines a trait&sup1; named `Copy` that signifies that a type may be
    copied instead whenever it would be moved.
- Most primitive types are `Copy` (`i32`, `f64`, `char`, `bool`, etc.)
- Types that contain references may not be `Copy` (e.g. `Vec`, `String`).
```rust
let x: i32 = 12;
let y = x; // `i32` is `Copy`, so it's not moved :D
println!("x still works: {}, and so does y: {}", x, y);
```

&sup1; Like a Java/Go interface or Haskell typeclass


---
## Borrowing Rules
##### _The Holy Grail of Rust_
Learn these rules, and they will serve you well.

- You can't keep borrowing something after it stops existing.
- One object may have many immutable references to it (`&T`).
- **OR** _exactly one_ mutable reference (`&mut T`) (not both).
- That's it!

.card[.small[.center[![Borrow Rules](images/sep_borrow_rules.png)]]]

---
### Borrowing Prevents...

- Use-after-free
- Valid in C, C++...

```rust
let y: &i32;
{
    let x = 5;
    y = &x; // error: `x` does not live long enough
}
println!("{}", *y);
```

- The full error message:

```
error: `x` does not live long enough
note: reference must be valid for the block suffix following statement
    0 at 1:16
...but borrowed value is only valid for the block suffix
    following statement 0 at 4:18
```

- This eliminates a _huge_ number of memory safety bugs _at compile time_.
- As a side note, this technique of creating a block to limit the scope of a
variable (in this case x) is pretty useful.

---

## Enum

- An enum, or "sum type", is a way to express some data that may be one of several things.
- Similar to the union type in C
- Much more powerful than in Java, C, C++, C#...
- Each enum variant can have optional payloads:
    - no data (unit variant)
    - named data (struct variant)
    - unnamed ordered data (tuple variant)

```rust
enum Resultish {
    Ok,
    Warning { code: i32, message: String },
    Err(String)
}
```

---
### Enum `match`-ing

- Enum variants are namespaced by their enum type: `Resultish::Ok`.
    - You can import all variants with `use Resultish::*`.
- Enums, much as you'd expect, can be matched on like any other data type.

.column[
```rust
match make_request() {
    Resultish::Ok =>
        println!("Success!"),
    Resultish::Warning { code, message } =>
        println!("Warning: {}!", message),
    Resultish::Err(s) =>
        println!("Failed with error: {}", s),
}
```
]

.column[
.card[.small_vertical[.center[![Enum](images/sep_match_example.png)]]]
]

---

class: split-70

## `Option` .top_image[![Seatbelt](images/seatbelt.png)] 

- Rust has no NULL type
- a variable of a type has to store a value of that actual type
- a reference has to exist and point to a valid memory

Use `Option` enum

.column[
```rust
enum Option<T> {
  Some(T)
  None,
}
```

T is any valid type
]

.column[
.card[.small_vertical[.center[![Option](images/sep_option.png)]]]
]

---

## `Option` example

Rust automatically imports  `Option::*`

```rust
fn integer_division (a:isize, b: isize) -> Option<isize> {
  if b == 0 {
    None
  } else {
    Some(a / b)
  }
}

fn main () {
  let x = 120;
  let y = 7;
  match integer_division (x, y) {
    Some(d) => println! ("{}:{} = {}", x, y, d),
    None => println! ("division by 0")
  };
  // or
  println! ("{}:{} = {}", x, y, integer_division (x, y).unwrap()),
}
```
---
# Lifetimes Annotations

- Lifetimes generally have a pretty steep learning curve.
- Don't worry if you don't understand these right away.

.title[.center[![Din Lac in Put](images/mieuneli_din_lac_in_put.png)]]

---
### Question .top_image[![Questions](images/question.svg)]

Q1: How do you use free?

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char * without_first_word (char *s);

int main ()
{
    char * s = strdup ("ana has apples");
    char *wfw = without_first_word (s);
    // free (s);   <-- before printf
    printf ("%s\n", wfw);
    // free (wfw); <-- after printf
}

```

---
### Question .top_image[![Questions](images/question.svg)]

Q2: How do you use free?

```c
// program: bear-salamander-anteater
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char * without_first_word (char *s) {
    int pos = 0;
    for (unsigned int i=0; i < strlen (s); i++) {
        if (s[i] != ' ') pos = pos + 1;
        else break;
    }
    return &s[pos];
}

int main ()
{
    char * s = strdup ("ana has apples");
    char *wfw = without_first_word (s);
    // free (s);    <-- before printf
    printf ("%s\n", wfw);
    // free (wfw);  <-- after printf
}

```

---
### Question .top_image[![Questions](images/question.svg)]

Q3: How do you use free?

```c
// program: oyster-guanaco-dinosaur
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char * without_first_word (char *s) {
    int pos = 0;
    for (unsigned int i=0; i < strlen (s); i++) {
        if (s[i] != ' ') pos = pos + 1;
        else break;
    }
    return strdup (&s[pos]);
}

int main ()
{
    char * s = strdup ("ana has apples");
    char *wfw = without_first_word (s);
    // free (s);   <-- before printf
    printf ("%s\n", wfw);
    // free (wfw);  <-- before printf
}

```

---
### Lifetime annotations

From a birds eye view, how should Rust free `s` and `wfw`?

```rust
fn without_first_word<'a> (s: &'a str) -> &'a str;

fn main() {
    let s = String::from("ana has apples"); 
    let wfw = without_first_word (&s);      
    // drop (s);
    println! ("{}", wfw);                  
    // drop (wfw);
}                                         
```


---
### This is why lifetimes are useful.

```rust
fn without_first_word<'a> (s: &'a str) -> &'a str {
    let mut pos = 0;
    for a in s.chars() {
        if a != ' ' { pos = pos + 1; }
        else { break; }
    }
    &s[pos..]
}

fn main() {
    let s = String::from("ana has apples");
    let wfw = without_first_word (&s);
    // drop (s);
    println! ("{}", wfw);
}
```

---
### Efective Lifetimes 

```rust
fn without_first_word<'a> (s: &'a str) -> &'a str {
    let mut pos = 0;
    for a in s.chars() {
        if a != ' ' { pos = pos + 1; }
        else { break; }
    }
    &s[pos..]
}

fn main() {
    let s = String::from("ana has apples"); // <--- s lifetime ('ls) starts here
    let wfw = without_first_word (&s);      // <--- wfw lifetime ('lwfw) starts here
    // drop (s);                            // <--- s lifetime ('ls) ends here, wfw lifetime ('wfw) ends here (due to 'ls)
                                            //      t lifetime ('ts) starts here
    println! ("{}", wfw);                   // <--- wfw lifetime ('lwfw) actually ends here
}                                           // <--- t lifetime ('ts) ends here
```

---
### Lifetime annotations

```rust
fn without_first_word<'a> (s: &'a str) -> &'a str;

fn main() {
    let s = String::from("ana has apples"); // <--- s lifetime ('ls) starts here
    let wfw = without_first_word (&s);      // <--- wfw lifetime ('lwfw) starts here
    // drop (s);                            // <--- s lifetime ('ls) ends here, wfw lifetime ('wfw) ends here (due to 'ls)
                                            //      t lifetime ('ts) starts here
    println! ("{}", wfw);                   // <--- wfw lifetime ('lwfw) actually ends here
}                                           // <--- t lifetime ('ts) ends here
```

---
### Question .top_image[![Questions](images/question.svg)]

Can we use free for `s1` and `s2` before `printf`?

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char * smaller (char *s1, char *s2);

int main () {
    char *s1 = strdup ("ip");
    char *s2 = strdup ("workshop");
    char *small = smaller (s1, s2);
    // free (s1);
    // free (s2);
    printf ("%s\n", small);
}

```

---
### Multiple Lifetime Parameters

```c
// program: wolverine-mallard-gull
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char * smaller (char *s1, char *s2) {
    if (strlen(s1) > strlen(s2)) return s2;
    else return s1;
}

int main () {
    char *s1 = strdup ("ip");
    char *s2 = strdup ("workshop");
    char *small = smaller (s1, s2);
    // free (s1);
    // free (s2);
    printf ("%s\n", small);
}

```

---
### Multiple Lifetime Parameters

```rust
fn smaller <'a> (s1: &'a str, s2: &'a str) -> &'a str {}

fn main() {
    let s1 = String::from("ip"); 
    let s2 = String::from("workshop"); 
    let small = smaller (&s1, &s2);
    // drop (s1);
    // drop (s2);
    println! ("{}", small);                  
}                                          
```

---
### Question .top_image[![Questions](images/question.svg)]

Why can't we free s2?

```rust
fn append <'a> (s: &'a mut String, n: &'a str) -> &'a str {
    s.push_str (n);
    s
}

fn main() {
    let mut s1 = String::from("ip"); 
    let s2 = String::from(" workshop"); 
    let title = append (&mut s1, &s2);
    // drop(s1);
    drop(s2);
    println! ("{}", title);                  
}                                          
```
---
### Multiple Lifetime Parameters

We now can free s2. 

```rust
fn append <'a, 'b> (s: &'a mut String, n: &'b str) -> &'a str {
    s.push_str (n);
    s
}

fn main() {
    let mut s1 = String::from("ip"); 
    let s2 = String::from(" workshop"); 
    let title = append (&mut s1, &s2);
    // drop (s1);
    drop (s2);
    println! ("{}", title);                  
}                                          
```

---

# Links

- [Website](https://www.rust-lang.org/)
- [The Rust Programming Language](https://doc.rust-lang.org/stable/book/)
- [Tour of Rust](https://tourofrust.com/)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script src="script/playground.js">
    </script>
    <script>
      var slideshow = remark.create({
		navigation: {
				scroll: false
			}
    });
    window.cPlaygroundUrl = "https://cplayground.com/";
    window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
  </body>
</html>
